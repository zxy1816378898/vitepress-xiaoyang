Java 的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。例如：

```java
public class Main {
    public static void main(String[] args) {
        int i = (100 + 200) * (99 - 88); // 3300
        int n = 7 * (5 + (i - 9)); // 23072
        System.out.println(i);
        System.out.println(n);
    }
}
```

整数的数值表示不但是精确的，而且整数运算<font style="color: var(--vp-c-brand);">永远是精确的</font> ，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：

```java
int x = 12345 / 67; // 184
```

求余运算使用<code>%</code>：

```java
int y = 12345 % 67; // 12345÷67的余数是17
```

特别注意：整数的除法对于除数为 0 时运行时将报错，但编译不会报错。

### 溢出

要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<font style="color: var(--vp-c-brand);">不会出错</font>，却会得到一个奇怪的结果：

```java
public class Main {
    public static void main(String[] args) {
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    }
}
```

要解释上述结果，我们把整数<code>2147483640</code> 和 <code>15</code> 换成二进制做加法：

```java
        0111 1111 1111 1111 1111 1111 1111 1000
+ 0000 0000 0000 0000 0000 0000 0000 1111
-----------------------------------------
  1000 0000 0000 0000 0000 0000 0000 0111
```

由于最高位计算结果为<code>1</code> ，因此，加法结果变成了一个负数。

要解决上面的问题，可以把<code>int</code> 换成 <code>long</code> 类型，由于 long 可表示的整型范围更大，所以结果就不会溢出：

```java
long x = 2147483640;
long y = 15;
long sum = x + y;
System.out.println(sum); // 2147483655
```

还有一种简写的运算符，即<font style="color: var(--vp-c-brand);">+=，-=，\*=，/=</font>，它们的使用方法如下：

```java
n += 100; // 3409, 相当于 n = n + 100;
n -= 100; // 3309, 相当于 n = n - 100;
n *= 100; // 340900, 相当于 n = n * 100;
n /= 100; // 3409, 相当于 n = n / 100;
```

### 自增/自减

Java 还提供了<code>++</code>运算和<code>--</code>运算，它们可以对一个整数进行加 1 和减 1 的操作：

```java
public class Main {
    public static void main(String[] args) {
        int n = 3300;
        n++; // 3301, 相当于 n = n + 1;
        n--; // 3300, 相当于 n = n - 1;
        int y = 100 + (++n); // 不要这么写
        System.out.println(y);
    }
}
```

注意<code>++</code>写在前面和后面计算结果是不同的，<code>++n</code>表示先加 <code>1</code> 再引用 <code>n</code>，<code>n++</code>表示先引用 <code>n</code> 再加 <code>1</code>。不建议把<code>++</code>运算混入到常规运算中，容易自己把自己搞懵了。

### 移位运算

在计算机中，整数总是以二进制的形式表示。例如，<code>int</code> 类型的整数 7 使用 4 字节表示的二进制如下：

```java
00000000 0000000 0000000 00000111
```

可以对整数进行移位运算。对整数 7 左移 1 位将得到整数 14，左移两位将得到整数 28：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
```

左移 29 位时，由于最高位变成 1，因此结果变成了负数。

类似的，对整数 28 进行右移，结果如下：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

如果对一个负数进行右移，最高位的 1 不动，结果仍然是一个负数：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

还有一种无符号的右移运算，使用<code>>>></code>，它的特点是不管符号位，右移后高位总是补 0，因此，对一个负数进行<code>>>></code>右移，它会变成正数，原因是最高位的 1 变成了 0：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

对<code>byte</code> 和 <code>short</code> 类型进行移位时，会首先转换为<code>int</code> 再进行位移。

仔细观察可发现，左移实际上就是不断地 ×2，右移实际上就是不断地 ÷2。

### 位运算

位运算是按位进行与、或、非和异或的运算。

与运算的规则是，必须两个数同时为 <code>1</code>，结果才为 <code>1</code>：

```java
n = 0 & 0; // 0
n = 0 & 1; // 0
n = 1 & 0; // 0
n = 1 & 1; // 1
```

或运算的规则是，只要任意一个为 <code>1</code>，结果就为 <code>1</code>：

```java
n = 0 | 0; // 0
n = 0 | 1; // 1
n = 1 | 0; // 1
n = 1 | 1; // 1
```

非运算的规则是， <code>0</code> 和 <code>1</code> 互换：

```java
n = ~0; // 1
n = ~1; // 0
```

异或运算的规则是，如果两个数不同，结果为 <code>1</code>，否则为 <code>0</code>：

```java
n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0
```

对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：

```java
  public class Main {
    public static void main(String[] args) {
        int i = 167776589; // 00001010 00000000 00010001 01001101
        int n = 167776512; // 00001010 00000000 00010001 00000000
        System.out.println(i & n); // 167776512
    }
}
```

上述按位与运算实际上可以看作两个整数表示的 IP 地址 <code>10.0.17.77</code>和 <code>10.0.17.0</code>，通过与运算，可以快速判断一个 IP 是否在给定的网段内。

### 运算优先级

在 Java 的计算表达式中，运算优先级从高到低依次是：

-   <code>()</code>：括号运算
-   <code>++</code>，<code>--</code>：后缀递增和递减
-   <code>++</code>，<code>--</code>：前缀递增和递减
-   <code>+</code>，<code>-</code>：正负号
-   <code>!</code>，<code>~</code>：逻辑非和按位取反
-   <code>\*/%</code>：乘、除、取余
-   <code>+</code>，<code>-</code>：加、减
-   <code><<</code>，<code>>></code>，<code>>>></code>：移位
-   <code><</code>，<code><=</code>，<code>></code>，<code>>=</code>：比较运算符
-   <code>==</code>，<code>!=</code>：相等和不相等
-   <code>&</code>：按位与
-   <code>^</code>：按位异或
-   <code>|</code>：按位或
-   <code>&&</code>：逻辑与
-   <code>||</code>：逻辑或
-   <code>? :</code>：三元运算符

记不住也没关系，只需要加括号就可以保证运算的优先级正确。

### 类型自动提升与强制转型

在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，<code>short</code> 和 <code>int</code> 计算，结果总是<code>int</code> ，原因是<code>short</code> 首先自动被转型为 <code>int</code>

```java
public class Main {
    public static void main(String[] args) {
        short s = 1234;
        int i = 123456;
        int x = s + i; // s自动转型为int
        short y = s + i; // 编译错误!
    }
}
```

也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用<code>(类型)</code>，例如，将 <code>int</code> 强制转型为 <code>short</code>

```java
int i = 12345;
short s = (short) i; // 12345
```

要注意，超出范围的强制转型会得到错误的结果，原因是转型时，<code>int</code> 的两个高位字节直接被扔掉，仅保留了低位的两个字节：

```java
public class Main {
    public static void main(String[] args) {
        int i1 = 1234567;
        short s1 = (short) i1; // -10617
        System.out.println(s1);
        int i2 = 12345678;
        short s2 = (short) i2; // 24910
        System.out.println(s2);
    }
}
```

因此，强制转型的结果很可能是错的。

### 小结

整数运算的结果永远是精确的；

运算结果会自动提升；

可以强制转型，但超出范围的强制转型会得到错误的结果；

应该选择合适范围的整型（<code>int</code> 或 <code>long</code>），没有必要为了节省内存而使用 byte 和 short 进行整数运算。
